@name 
@inputs DigitalScreen:wirelink Lights:entity
@outputs 
@persist X Y MaxCpu ScreenResolution T:table Render Denoise BackBuffer:table RenderBuffer:table Sample Passes:array PassesArguments:array
@trigger

runOnTick(1)

if( first() ){
    
    ##include "texture"
    
    function vector render(RangerDirection:vector){
        
        Ranger = rangerOffset(9999999, entity():pos(), RangerDirection)
        
        Color = vec(1)
        FinalColor = vec(0)
        
        Light = 0
        
        if(Ranger:entity() == Lights){
            
            return vec(1)
            
        }
        
        if(Ranger:hitSky()){
            
            return vec(0.1, 0.5, 1)
            
        }
        
        while(Ranger:entity() != Lights & !Ranger:hitSky() & Light < 2){
            
            
            Color = Color * (Ranger:entity():getColor() / 255 * !Ranger:hitWorld() + Ranger:hitWorld())
            
            LightsRanger = rangerOffset(Ranger:position(), Lights:pos() + randvec(-1, 1) * Lights:boxSize() / 2)
            
            FinalColor = FinalColor + Color * ( (LightsRanger:distance() != 0 ? (( (100000 /  LightsRanger:distance() ^ 2)) * (LightsRanger:entity() == Lights) * 
            max((Lights:pos() - Ranger:position()):normalized():dot(Ranger:hitNormal()), 0) * LightsRanger:hit()) : 0) +
            rangerOffset(99999999, Ranger:position(), vec(1.2, 1, 4)):hitSky() * max(Ranger:hitNormal():dot(vec(1.2, 1, 4):normalized()), 0) )
            
            Ranger = rangerOffset(99999999, Ranger:position(), vec(1 / sin(random() * 90) - 1, random() * 2 - 1, random() * 2 - 1):normalized():rotate(Ranger:hitNormal():toAngle()))
            
            Light = Light + 1
            
        }
        
        return FinalColor / (FinalColor + 1)
        
    }
    
    function addPass(PassName:string, ScreenCordinates){
        
        Passes:pushString(PassName)
        PassesArguments:pushNumber(ScreenCordinates)
        
    }
    
    function number getMaxCpu(){
        
        return 10000 / 1000000
        
    }
    
    MaxCpu = getMaxCpu()
    
    function wirelink:initScreen(Res){
        Scr = This
        Scr[1048574]=0 #Reset Screen and whatever was on it will be cleared.
        Scr[1048569]=2 #Set color mode to 3
        Scr[1048575]=1 #Apply changes
        Scr[1048572]=Res #Set new resolution on Y (Height)
        Scr[1048573]=Res #Set new resolution on X (Width)
        Scr["PixelG",number] = 999
    }
    DigitalScreen:initScreen(ScreenResolution)
    
    ScreenResolution = 512 / 2
    
    Render = 1
    
    BackBuffer = table()
    
    Passes = array("render")
    PassesArguments = array(0)
    
}

if(changed(DigitalScreen) | (!first() & changed(first()))){
    
    DigitalScreen:initScreen(ScreenResolution)
    
}

while(opcounter() < softQuota() * 0.9 & cpuUsage() < MaxCpu & !first() & Render){
    
    X = X + (X < ScreenResolution ? 1 : -ScreenResolution + 1)
    Render = Passes:count() == 0 ? 0 : 1
    if(Y >= ScreenResolution) { Passes:remove(1) }
    Y = Y + (Y < ScreenResolution ? X == ScreenResolution - 1 : -ScreenResolution + 1)
    
    RangerDirection = vec(0.5, -X / ScreenResolution + 0.5, -Y / ScreenResolution + 0.5):rotate(entity():angles())
    
    RenderColor = vec(0)
    
    for(I = 1, Sample){
        
        Pass = Passes:string(1)
        
        if(PassesArguments:number(1)){
            
            RenderColor = RenderColor + Pass(RangerDirection, X, Y)[vector] * (1 / Sample)
            
        }
        else{
            
            RenderColor = RenderColor + Pass(RangerDirection)[vector] * (1 / Sample)
            
        }
        
    }
    
    RenderBuffer[X + Y * ScreenResolution, vector] = RenderColor
    DigitalScreen[X + Y * ScreenResolution] = rgb2digi(RenderColor * 255, 2)

}
